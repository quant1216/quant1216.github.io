---
title: "SelfTestingCode"
source: https://martinfowler.com/bliki/SelfTestingCode.html
date: 2020-06-05 17:00:00
categories: testing
---
<h1>단순 번역 및 요약</h1>
<h2>SelfTestingCode</h2>
<h3>Self-Testing Code는 제가 리팩토링 문서에서 포괄적인 자동화 테스트들과 functional software를 함께 만드는 관행을 나타내기 위해 사용한 단어입니다. 이 작업이 잘 마무리되었다면 당신은 하나의 커멘드로 테스트들을 실행시킬 수 있습니다. 또한 당신은 테스트들이 당신의 코드에 숨어있는 어떤 버그라도 찾아냈다는 확신을 가질 수 있습니다.

처음 이 생각을 하게 된 계기는 OOPSLA conference에서 "Beddara" Dave Thomas의 모든 object는 그 자신을 테스트할 수 있어야 한다는 말에서 시작됬습니다. 저는 불현듯 command를 작성하는 것과 나의 모든 소프트웨어 시스템이 self-test를 하는 것에 대해 상상해보았습니다(당신이 부스팅할 때 하드웨어 메모리 테스트들을 보던 것과 동일한 방식으로). 곧 나는 이 접근 방법을 나의 프로젝트 내에서 적용하고 있었으며 이로 인한 이점들로 인해 행복해졌습니다. 약 2년 뒤, 나는 Kent Beck과 일을 했고 그도 동일한 행동을 했다는 것을 알았습니다. 하지만 그의 생각은 훨씬 정교했습니다. 이는 Kent가 JUnit을 만들기 직전이었습니다. JUnit은 TDD와 함께 self-testing code에 대한 대부분의 사고 방식과 방법에 대한 기초를 만든 도구가 되었습니다.

당신의 코드에 대해 자동화된 테스트들을 실행하여 통과했을 때 당신은 self-testing code를 갖는 것입니다. 당신의 코드는 상당한 결함들로부터 자유로워진 것입니다. 내 생각에 이 일은 당신의 소프트웨어 시스템을 만드는 것만큼이나 중요한 일이라고 생각합니다. 당신은 당신의 시스템에 존재하는 어떠한 실수들도 감지할 수 있는 버그 탐지기를 동시에 만드는 것입니다. 팀의 일원이 실수로 버그를 만들 수도 있으나 이 감지기는 이 문제를 없앨 것입니다. test suite를 하루에 몇 번씩 자주 돌림으로써, 당신은 당신은 어떤 버그가 만들어지면 바로 감지할 수 있을 것입니다. 당신은 단지 최근의 변화 사항들만 보면 되고 이는 버그를 더욱 찾기 쉽게 만들 것입니다. 동작하는 코드와 이를 유지하는 테스트가 없다면 어떤 프로그래밍도 완벽하지 않은 것입니다. 우리는 테스트가 없는 경우에는 어떠한 사소한 코드라 시스템을 고장낸다고 가정해야 합니다. 

Self-testing code는 CI의 핵심 부분입니다. 실제로 저는 당신이 self-testing code를 사용하지 않는다면 CI가 아니라고 말했습니다. CI의 기둥으로써, self-testing code는 CD의 필요한 부분이기도 합니다.

Self-testing code의 명확한 이점은 제품에 있는 수많은 버그들을 매우 줄일 수 있다는 것입니다. 이 작업의 핵심은 개발자들이 코드 작성과 테스트 작성을 함께 생각하는 testing 문화를 만드는 것입니다.

하지만 가장 큰 이점은 단순히 제품의 버그를 없애는 것이 아닙니다. 가장 큰 이점은 당신이 시스템을 수정할 때 문제가 없다는 확신이 생긴다는 것입니다. 오래된 코드베이스들은 매우 무서운 영역입니다. 개발자는 동작하고 있는 코드를 수정하는데 두려움을 느낄 수 있습니다. 심지어 버그를 고치는 것조차 고치는 것보다 더 많은 버그를 생성할 수도 있기 때문에 위험할 수 있습니다. 이런 환경들은 새로운 피처를 추가하는데 심각하게 느려지게 만들 뿐 아니라 시스템을 리팩토링하는 것에 두렴움을 느끼게 하고 그럼으로써 techinical debt를 증가시키고 점점 더 안 좋아지는 소용돌이 속으로 들어가는 것입니다. 변경 사항이 많이 생길 수록 더 많은 공포감을 느끼게 할 것입니다.

Self-testing code를 이용하면 이것은 다른 문제가 됩니다. 사람들은 코드를 정리하는 조그마한 문제를 수정할 때 안전하게 진행한다는 확신을 얻을 수 있습니다. 당신이 실수를 한다면 버그 탐지기가 동작할 것이고 당신은 빠르게 이를 수정하고 계속할 수 있습니다. 이런 안전망이 있다면, 당신은 코드를 더 좋은 형태로 유지하는데 시간을 쓸 수 있고 새로운 피처를 추가할 때 꾸준히 더 빨라지는 선순환 속으로 들어간느 것입니다.

이 이점들은 종종 TDD와 관련하여 얘기되곤 하지만 TDD와 self-testing code의 개념을 분리하는 것이 유용합니다. 나는 TDD가 self-testing code를 만드는 것을 포함하는 특정 예시라고 생각합니다. TDD는 self-testing code를 만드는 좋은 방법이고, 저는 TDD는 매우 좋아합니다. 하지만 당신은 코드를 작성한 이후에 self-testing code를 작성해도 됩니다. 비록 당신이 테스트를 만들고 통과하기 전에는 당신의 작업이 끝났다고 생각할 순 없습니다. 중요한 사안은 어떻게 만들었는지가 중요한 것이 아니라 self-testing code가 있다는 것입니다.

Self-testing code를 준비하는 팀에게 가장 중요한 행동은 제품 버그에 대한 반응입니다. self-testing code를 사용하는 팀의 평사시 반응은 먼저 버그가 나오는 테스트를 만들고 그 다음 이를 고치는 것입니다. 종종 테스트를 만드는 것은 버그를 실행시키는 unit test에 다다를 때까지 스코프를 점차 줄여나가는 연속적인 테스트들이 될 것입니다. 이것은 디버깅 방법으로도 유용하고 버그가 고쳐지고, 고쳐진 상태를 유지하고 있는지 보장하기 위해서 필수적입니다. 보통 팀들은 해당 버그를 비슷하게 놓치고 있는 다른 테스트들을 들여다보는 동기로 사용할 것입니다. 어떠한 버그도 단지 코드에서의 실패가 아니라, 이것은 유저의 화면에서 테스트를 실패하는 것과 동일하다고 생각하는 자세가 필요합니다.

최근 우리는 제품을 모니터링하는 과정 속에서 self-testing의 또다른 측면을 점차 알아가고 있습니다. CD는 당신이 빠르게 새로운 버전의 소프트웨어를 제품으로 만들 수 있게 도와줍니다. 이 상황 속에서 팀들은 제품의 버그를 한 번에 찾고 빠르게 수정하기 위해 노력을 기울입니다.

<h1>나에게 하는 말</h1>

* tests를 열심히 짜자.